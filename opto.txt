-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | General-purpose performant numeric optimization library
--   
--   Please see the README on Github at
--   <a>https://github.com/mstksg/opto#readme</a>
@package opto
@version 0.1.0.0


-- | Abstract over different types for mutable references of values.
module Numeric.Opto.Ref

-- | Abstraction over types of mutable references for values. A
--   <tt><a>Ref</a> m a v</tt> means that a <tt>v</tt> is a mutable
--   reference to an <tt>a</tt>, and we may update<i>write</i>modify
--   <tt>v</tt> in context <tt>m</tt>.
--   
--   This allows us to reat mutable vectors and in-place mutable numbers or
--   records in the same way.
class Monad m => Ref m a v | v -> a

-- | Initialize a mutable reference with a given value
thawRef :: Ref m a v => a -> m v

-- | Read an immutable value back from a mutable reference
freezeRef :: Ref m a v => v -> m a

-- | Copy an immutable value into a mutable reference
copyRef :: Ref m a v => v -> a -> m ()

-- | Apply a pure function on an immutable value onto a value stored in a
--   mutable reference.
modifyRef :: Ref m a v => v -> (a -> a) -> m ()

-- | <a>modifyRef</a>, but forces the result before storing it back in the
--   reference.
modifyRef' :: Ref m a v => v -> (a -> a) -> m ()

-- | Apply a pure function on an immutable value onto a value stored in a
--   mutable reference, returning a result value from that function.
updateRef :: Ref m a v => v -> (a -> (a, b)) -> m b

-- | <a>updateRef</a>, but forces the updated value before storing it back
--   in the reference.
updateRef' :: Ref m a v => v -> (a -> (a, b)) -> m b
instance (Control.Monad.Primitive.PrimMonad m, Control.Monad.Primitive.PrimState m Data.Type.Equality.~ s) => Numeric.Opto.Ref.Ref m a (Data.Primitive.MutVar.MutVar s a)
instance (Control.Monad.Primitive.PrimMonad m, Control.Monad.Primitive.PrimState m Data.Type.Equality.~ s) => Numeric.Opto.Ref.Ref m (Data.Vector.Vector a) (Data.Vector.Mutable.MVector s a)
instance (Control.Monad.Primitive.PrimMonad m, Data.Vector.Generic.Base.Mutable v Data.Type.Equality.~ mv, Control.Monad.Primitive.PrimState m Data.Type.Equality.~ s, Data.Vector.Generic.Base.Vector v a) => Numeric.Opto.Ref.Ref m (Data.Vector.Generic.Sized.Internal.Vector v n a) (Data.Vector.Generic.Mutable.Sized.Internal.MVector mv n s a)
instance GHC.Base.Monad m => Numeric.Opto.Ref.Ref m () ()
instance (GHC.Base.Monad m, Numeric.Opto.Ref.Ref m a u, Numeric.Opto.Ref.Ref m b v) => Numeric.Opto.Ref.Ref m (a, b) (u, v)
instance (GHC.Base.Monad m, Numeric.Opto.Ref.Ref m a u, Numeric.Opto.Ref.Ref m b v, Numeric.Opto.Ref.Ref m c w) => Numeric.Opto.Ref.Ref m (a, b, c) (u, v, w)
instance (GHC.Base.Monad m, Numeric.Opto.Ref.Ref m a u, Numeric.Opto.Ref.Ref m b v, Numeric.Opto.Ref.Ref m c w, Numeric.Opto.Ref.Ref m d j) => Numeric.Opto.Ref.Ref m (a, b, c, d) (u, v, w, j)


-- | Conduits that are useful for sampling and running optimizers.
module Numeric.Opto.Run.Conduit

-- | Outputs a shuffled version of the input stream. Keeps entire input
--   stream in memory.
--   
--   NOTE: Pulls the entire input stream into memory first before
--   outputting anything.
shuffling :: PrimMonad m => Gen (PrimState m) -> ConduitT a a m ()

-- | Takes the first N items out of the input stream, shuffles them
--   in-memory, and outputs the shuffled result.
--   
--   Leaves the rest of the items in the stream.
--   
--   Use <a>forever</a> to repeat multiple times until the stream is
--   exhausted.
shufflingN :: PrimMonad m => Int -> Gen (PrimState m) -> ConduitT a a m ()

-- | Process an entire stream, and keep N random and shuffled items from
--   that stream. Is O(N) memory.
sinkSampleReservoir :: forall m v a o. (PrimMonad m, Vector v a) => Int -> Gen (PrimState m) -> ConduitT a o m (v a)

-- | Process an entire stream, and yield N random items from that stream.
--   Is O(N) memory.
--   
--   NOTE: Exhausts the entire input stream first before outputting
--   anything, but never keeps the entire original stream in memory.
samplingN :: PrimMonad m => Int -> Gen (PrimState m) -> ConduitT a a m ()

-- | Drops and lets items through randomly with a given probability.
skipSampling :: PrimMonad m => Double -> Gen (PrimState m) -> ConduitT a a m ()

module Numeric.Opto.Update
class Additive a
(.+.) :: Additive a => a -> a -> a
addZero :: Additive a => a
(.+.) :: (Additive a, Num a) => a -> a -> a
addZero :: (Additive a, Num a) => a
infixl 6 .+.
sumAdditive :: (Additive a, Foldable t) => t a -> a
gAdd :: (ADTRecord a, Constraints a Additive) => a -> a -> a
gAddZero :: (ADTRecord a, Constraints a Additive) => a
class (Num c, Additive a) => Scaling c a | a -> c
(.*) :: Scaling c a => c -> a -> a
scaleOne :: Scaling c a => c
(.*) :: (Scaling c a, ADTRecord a, Constraints a (Scaling c)) => c -> a -> a
infixl 7 .*
gScale :: forall c a. (ADTRecord a, Constraints a (Scaling c)) => c -> a -> a
class Scaling c a => Metric c a

-- | Sum of component-wise product
(<.>) :: Metric c a => a -> a -> c

-- | Maximum absolute component
norm_inf :: Metric c a => a -> c

-- | Number of non-zero components
norm_0 :: Metric c a => a -> c

-- | Sum of absolute components
norm_1 :: Metric c a => a -> c

-- | Square root of sum of squared components
norm_2 :: Metric c a => a -> c

-- | Sum of squared components
quadrance :: Metric c a => a -> c

-- | Sum of component-wise product
(<.>) :: (Metric c a, ADT a, Constraints a (Metric c)) => a -> a -> c

-- | Maximum absolute component
norm_inf :: (Metric c a, ADT a, Constraints a (Metric c), Ord c) => a -> c

-- | Number of non-zero components
norm_0 :: (Metric c a, ADT a, Constraints a (Metric c)) => a -> c

-- | Sum of absolute components
norm_1 :: (Metric c a, ADT a, Constraints a (Metric c)) => a -> c

-- | Square root of sum of squared components
norm_2 :: (Metric c a, Floating c) => a -> c

-- | Sum of squared components
quadrance :: (Metric c a, ADT a, Constraints a (Metric c)) => a -> c
infixl 7 <.>
gNorm_inf :: forall c a. (ADT a, Constraints a (Metric c), Ord c) => a -> c
gNorm_0 :: forall c a. (ADT a, Constraints a (Metric c), Num c) => a -> c
gNorm_1 :: forall c a. (ADT a, Constraints a (Metric c), Num c) => a -> c
gNorm_2 :: forall c a. (ADT a, Constraints a (Metric c), Floating c) => a -> c
gQuadrance :: forall c a. (ADT a, Constraints a (Metric c), Num c) => a -> c
class (Ref m a v, Additive a) => AdditiveInPlace m v a
(.+.=) :: AdditiveInPlace m v a => v -> a -> m ()
infix 4 .+.=
sumAdditiveInPlace :: (AdditiveInPlace m v a, Foldable t) => v -> t a -> m ()
class (AdditiveInPlace m v a, Scaling c a) => ScalingInPlace m v c a
(.*=) :: ScalingInPlace m v c a => v -> c -> m ()
(.*+=) :: ScalingInPlace m v c a => v -> (c, a) -> m ()
infix 4 .*=
infix 4 .*+=
instance Numeric.Opto.Ref.Ref m GHC.Types.Double v => Numeric.Opto.Update.ScalingInPlace m v GHC.Types.Double GHC.Types.Double
instance (Control.Monad.Primitive.PrimMonad m, Control.Monad.Primitive.PrimState m Data.Type.Equality.~ s, GHC.Num.Num a, mv Data.Type.Equality.~ Data.Vector.Generic.Base.Mutable v, Data.Vector.Generic.Base.Vector v a, GHC.TypeNats.KnownNat n) => Numeric.Opto.Update.ScalingInPlace m (Data.Vector.Generic.Mutable.Sized.Internal.MVector mv n s a) a (Data.Vector.Generic.Sized.Internal.Vector v n a)
instance (GHC.TypeNats.KnownNat n, Numeric.Opto.Ref.Ref m (Internal.Static.R n) v) => Numeric.Opto.Update.ScalingInPlace m v GHC.Types.Double (Internal.Static.R n)
instance (GHC.TypeNats.KnownNat n, GHC.TypeNats.KnownNat k, Numeric.Opto.Ref.Ref m (Internal.Static.L n k) v) => Numeric.Opto.Update.ScalingInPlace m v GHC.Types.Double (Internal.Static.L n k)
instance (Numeric.Opto.Ref.Ref m (a, b) v, Numeric.Opto.Update.Scaling c a, Numeric.Opto.Update.Scaling c b) => Numeric.Opto.Update.ScalingInPlace m v c (a, b)
instance (Numeric.Opto.Ref.Ref m (a, b, d) v, Numeric.Opto.Update.Scaling c a, Numeric.Opto.Update.Scaling c b, Numeric.Opto.Update.Scaling c d) => Numeric.Opto.Update.ScalingInPlace m v c (a, b, d)
instance (Numeric.Opto.Ref.Ref m (a, b, d, e) v, Numeric.Opto.Update.Scaling c a, Numeric.Opto.Update.Scaling c b, Numeric.Opto.Update.Scaling c d, Numeric.Opto.Update.Scaling c e) => Numeric.Opto.Update.ScalingInPlace m v c (a, b, d, e)
instance (Numeric.Opto.Ref.Ref m (a, b, d, e, f) v, Numeric.Opto.Update.Scaling c a, Numeric.Opto.Update.Scaling c b, Numeric.Opto.Update.Scaling c d, Numeric.Opto.Update.Scaling c e, Numeric.Opto.Update.Scaling c f) => Numeric.Opto.Update.ScalingInPlace m v c (a, b, d, e, f)
instance Numeric.Opto.Ref.Ref m GHC.Types.Double v => Numeric.Opto.Update.AdditiveInPlace m v GHC.Types.Double
instance (Control.Monad.Primitive.PrimMonad m, Control.Monad.Primitive.PrimState m Data.Type.Equality.~ s, GHC.Num.Num a, mv Data.Type.Equality.~ Data.Vector.Generic.Base.Mutable v, Data.Vector.Generic.Base.Vector v a, GHC.TypeNats.KnownNat n) => Numeric.Opto.Update.AdditiveInPlace m (Data.Vector.Generic.Mutable.Sized.Internal.MVector mv n s a) (Data.Vector.Generic.Sized.Internal.Vector v n a)
instance (GHC.TypeNats.KnownNat n, Numeric.Opto.Ref.Ref m (Internal.Static.R n) v) => Numeric.Opto.Update.AdditiveInPlace m v (Internal.Static.R n)
instance (GHC.TypeNats.KnownNat n, GHC.TypeNats.KnownNat k, Numeric.Opto.Ref.Ref m (Internal.Static.L n k) v) => Numeric.Opto.Update.AdditiveInPlace m v (Internal.Static.L n k)
instance (Numeric.Opto.Ref.Ref m (a, b) v, Numeric.Opto.Update.Additive a, Numeric.Opto.Update.Additive b) => Numeric.Opto.Update.AdditiveInPlace m v (a, b)
instance (Numeric.Opto.Ref.Ref m (a, b, c) v, Numeric.Opto.Update.Additive a, Numeric.Opto.Update.Additive b, Numeric.Opto.Update.Additive c) => Numeric.Opto.Update.AdditiveInPlace m v (a, b, c)
instance (Numeric.Opto.Ref.Ref m (a, b, c, d) v, Numeric.Opto.Update.Additive a, Numeric.Opto.Update.Additive b, Numeric.Opto.Update.Additive c, Numeric.Opto.Update.Additive d) => Numeric.Opto.Update.AdditiveInPlace m v (a, b, c, d)
instance (Numeric.Opto.Ref.Ref m (a, b, c, d, e) v, Numeric.Opto.Update.Additive a, Numeric.Opto.Update.Additive b, Numeric.Opto.Update.Additive c, Numeric.Opto.Update.Additive d, Numeric.Opto.Update.Additive e) => Numeric.Opto.Update.AdditiveInPlace m v (a, b, c, d, e)
instance Numeric.Opto.Update.Metric GHC.Types.Double GHC.Types.Double
instance (GHC.Float.Floating a, GHC.Classes.Ord a, Data.Vector.Generic.Base.Vector v a, GHC.TypeNats.KnownNat n) => Numeric.Opto.Update.Metric a (Data.Vector.Generic.Sized.Internal.Vector v n a)
instance GHC.TypeNats.KnownNat n => Numeric.Opto.Update.Metric GHC.Types.Double (Internal.Static.R n)
instance (GHC.TypeNats.KnownNat n, GHC.TypeNats.KnownNat m) => Numeric.Opto.Update.Metric GHC.Types.Double (Internal.Static.L n m)
instance (Numeric.Opto.Update.Metric c a, Numeric.Opto.Update.Metric c b, GHC.Classes.Ord c, GHC.Float.Floating c) => Numeric.Opto.Update.Metric c (a, b)
instance (Numeric.Opto.Update.Metric c a, Numeric.Opto.Update.Metric c b, Numeric.Opto.Update.Metric c d, GHC.Classes.Ord c, GHC.Float.Floating c) => Numeric.Opto.Update.Metric c (a, b, d)
instance (Numeric.Opto.Update.Metric c a, Numeric.Opto.Update.Metric c b, Numeric.Opto.Update.Metric c d, Numeric.Opto.Update.Metric c e, GHC.Classes.Ord c, GHC.Float.Floating c) => Numeric.Opto.Update.Metric c (a, b, d, e)
instance (Numeric.Opto.Update.Metric c a, Numeric.Opto.Update.Metric c b, Numeric.Opto.Update.Metric c d, Numeric.Opto.Update.Metric c e, Numeric.Opto.Update.Metric c f, GHC.Classes.Ord c, GHC.Float.Floating c) => Numeric.Opto.Update.Metric c (a, b, d, e, f)
instance Numeric.Opto.Update.Scaling GHC.Types.Double GHC.Types.Double
instance (GHC.Num.Num a, Data.Vector.Generic.Base.Vector v a, GHC.TypeNats.KnownNat n) => Numeric.Opto.Update.Scaling a (Data.Vector.Generic.Sized.Internal.Vector v n a)
instance GHC.TypeNats.KnownNat n => Numeric.Opto.Update.Scaling GHC.Types.Double (Internal.Static.R n)
instance (GHC.TypeNats.KnownNat n, GHC.TypeNats.KnownNat m) => Numeric.Opto.Update.Scaling GHC.Types.Double (Internal.Static.L n m)
instance (Numeric.Opto.Update.Scaling c a, Numeric.Opto.Update.Scaling c b) => Numeric.Opto.Update.Scaling c (a, b)
instance (Numeric.Opto.Update.Scaling c a, Numeric.Opto.Update.Scaling c b, Numeric.Opto.Update.Scaling c d) => Numeric.Opto.Update.Scaling c (a, b, d)
instance (Numeric.Opto.Update.Scaling c a, Numeric.Opto.Update.Scaling c b, Numeric.Opto.Update.Scaling c d, Numeric.Opto.Update.Scaling c e) => Numeric.Opto.Update.Scaling c (a, b, d, e)
instance (Numeric.Opto.Update.Scaling c a, Numeric.Opto.Update.Scaling c b, Numeric.Opto.Update.Scaling c d, Numeric.Opto.Update.Scaling c e, Numeric.Opto.Update.Scaling c f) => Numeric.Opto.Update.Scaling c (a, b, d, e, f)
instance Numeric.Opto.Update.Additive GHC.Types.Double
instance (GHC.Num.Num a, Data.Vector.Generic.Base.Vector v a, GHC.TypeNats.KnownNat n) => Numeric.Opto.Update.Additive (Data.Vector.Generic.Sized.Internal.Vector v n a)
instance Numeric.Opto.Update.Additive (Internal.Static.R n)
instance (GHC.TypeNats.KnownNat n, GHC.TypeNats.KnownNat m) => Numeric.Opto.Update.Additive (Internal.Static.L n m)
instance (Numeric.Opto.Update.Additive a, Numeric.Opto.Update.Additive b) => Numeric.Opto.Update.Additive (a, b)
instance (Numeric.Opto.Update.Additive a, Numeric.Opto.Update.Additive b, Numeric.Opto.Update.Additive c) => Numeric.Opto.Update.Additive (a, b, c)
instance (Numeric.Opto.Update.Additive a, Numeric.Opto.Update.Additive b, Numeric.Opto.Update.Additive c, Numeric.Opto.Update.Additive d) => Numeric.Opto.Update.Additive (a, b, c, d)
instance (Numeric.Opto.Update.Additive a, Numeric.Opto.Update.Additive b, Numeric.Opto.Update.Additive c, Numeric.Opto.Update.Additive d, Numeric.Opto.Update.Additive e) => Numeric.Opto.Update.Additive (a, b, c, d, e)

module Numeric.Opto.Core
type Diff a = a
type Grad m r a = r -> a -> m (Diff a)
data Opto :: (Type -> Type) -> Type -> Type -> Type -> Type
[MkOpto] :: forall s u m v r a c. (ScalingInPlace m v c a, Ref m s u) => {oInit :: !s, oUpdate :: !u -> r -> a -> m (c, Diff a)} -> Opto m v r a
fromCopying :: (PrimMonad m, ScalingInPlace m v c a) => s -> (r -> a -> s -> m (c, Diff a, s)) -> Opto m v r a
fromStateless :: ScalingInPlace m v c a => (r -> a -> m (c, Diff a)) -> Opto m v r a
pureGrad :: Applicative m => (r -> a -> Diff a) -> Grad m r a
nonSampling :: (a -> m (Diff a)) -> Grad m r a
pureNonSampling :: Applicative m => (a -> Diff a) -> Grad m r a


-- | Functions to <i>run</i> optimiziers.
module Numeric.Opto.Run

-- | Options for running an optimizer.
data RunOpts m a
RO :: (Diff a -> a -> m Bool) -> (a -> m ()) -> Maybe Int -> Int -> Maybe Int -> RunOpts m a

-- | Stop condition; will stop when <a>True</a> (default = never stop)
[roStopCond] :: RunOpts m a -> Diff a -> a -> m Bool

-- | Reporting function (default = no report)
[roReport] :: RunOpts m a -> a -> m ()

-- | number of batches to run (Nothing = run forever) (default = Nothing) |
--   Size of batching updates (1 = no batching) (default = 1)
[roLimit] :: RunOpts m a -> Maybe Int
[roBatch] :: RunOpts m a -> Int

-- | batches per report (Nothing = never report) (default = Just 1).
[roFreq] :: RunOpts m a -> Maybe Int
hoistRunOpts :: (forall x. m x -> n x) -> RunOpts m a -> RunOpts n a

-- | Options for running an optimizer in a concurrent setting.
data ParallelOpts
PO :: Maybe Int -> Int -> ParallelOpts

-- | Number of threads (Nothing = max capacity) (default = Nothing)
[poThreads] :: ParallelOpts -> Maybe Int
[poSplit] :: ParallelOpts -> Int
runOpto :: Monad m => RunOpts m a -> m (Maybe r) -> a -> Opto m v r a -> m (a, Opto m v r a)
evalOpto :: Monad m => RunOpts m a -> m (Maybe r) -> a -> Opto m v r a -> m a
runOptoNonSampling :: Monad m => RunOpts m a -> a -> Opto m v () a -> m (a, Opto m v () a)
evalOptoNonSampling :: Monad m => RunOpts m a -> a -> Opto m v () a -> m a
optoConduit :: Monad m => RunOpts m a -> a -> Opto (ConduitT r a m) v r a -> ConduitT r a m (Opto (ConduitT r a m) v r a)
optoConduit_ :: Monad m => RunOpts m a -> a -> Opto (ConduitT r a m) v r a -> ConduitT r a m ()

-- | <tt>runOptoSample</tt> specialized for <tt>FoldSampleT</tt>: give it a
--   collection of items <tt>rs</tt>, and it will process each item
--   <tt>r</tt>. Returns the optimized <tt>a</tt>, the leftover
--   <tt>rs</tt>, and a closure <a>Opto</a> that can be resumed.
foldOpto :: (Monad m, IsSequence rs, r ~ Element rs) => RunOpts m a -> a -> Opto (StateT rs m) v r a -> rs -> m (a, rs, Opto (StateT rs m) v r a)
foldOpto_ :: (Monad m, IsSequence rs, r ~ Element rs) => RunOpts m a -> a -> Opto (StateT rs m) v r a -> rs -> m (a, rs)
evalOptoParallel :: forall m v r a. (MonadUnliftIO m, Fractional a) => RunOpts m a -> ParallelOpts -> m (Maybe r) -> a -> Opto m v r a -> m a
evalOptoParallelChunk :: forall m v r a rs. (MonadUnliftIO m, Fractional a, IsSequence rs, r ~ Element rs) => RunOpts m a -> ParallelOpts -> (Int -> m rs) -> a -> Opto (StateT rs m) v r a -> m a
optoConduitParallel :: forall m v r a. (MonadUnliftIO m, Fractional a) => RunOpts m a -> ParallelOpts -> a -> Opto m v r a -> ConduitT () r m () -> ConduitT () a m ()
optoConduitParallelChunk :: forall m v r a. (MonadUnliftIO m, Fractional a) => RunOpts m a -> ParallelOpts -> a -> Opto (StateT [r] m) v r a -> ConduitT () r m () -> ConduitT () a m ()
instance (GHC.Num.Num a, GHC.Num.Num b) => GHC.Base.Semigroup (Numeric.Opto.Run.Sum2 a b)
instance (GHC.Num.Num a, GHC.Num.Num b) => GHC.Base.Monoid (Numeric.Opto.Run.Sum2 a b)
instance Data.Default.Class.Default Numeric.Opto.Run.ParallelOpts
instance GHC.Base.Applicative m => Data.Default.Class.Default (Numeric.Opto.Run.RunOpts m a)
instance Data.Functor.Contravariant.Contravariant (Numeric.Opto.Run.RunOpts m)

module Numeric.Opto.Optimizer
steepestDescent :: ScalingInPlace m v c a => c -> Grad m r a -> Opto m v r a
newtype Momentum c
Momentum :: c -> Momentum c
[momentumDecay] :: Momentum c -> c
momentum :: forall m v r a c. (PrimMonad m, ScalingInPlace m v c a) => Momentum c -> c -> Grad m r a -> Opto m v r a
newtype Nesterov c
Nesterov :: c -> Nesterov c
[nesterovDecay] :: Nesterov c -> c
nesterov :: forall m v r a c. (PrimMonad m, ScalingInPlace m v c a) => Nesterov c -> c -> Grad m r a -> Opto m v r a
data Adam c
Adam :: !c -> !c -> !c -> !c -> Adam c
[adamStep] :: Adam c -> !c
[adamDecay1] :: Adam c -> !c
[adamDecay2] :: Adam c -> !c
[adamEpsilon] :: Adam c -> !c
adam :: forall m v r a c. (RealFloat c, Floating a, ScalingInPlace m v c a, PrimMonad m) => Adam c -> Grad m r a -> Opto m v r a
data AdaMax c
AdaMax :: !c -> !c -> !c -> !c -> AdaMax c
[adaMaxStep] :: AdaMax c -> !c
[adaMaxDecay1] :: AdaMax c -> !c
[adaMaxDecay2] :: AdaMax c -> !c
[adaMaxEpsilon] :: AdaMax c -> !c
adaMax :: forall m v r a c. (RealFloat c, Metric c a, ScalingInPlace m v c a, PrimMonad m) => AdaMax c -> Grad m r a -> Opto m v r a
instance GHC.Classes.Eq c => GHC.Classes.Eq (Numeric.Opto.Optimizer.AdaMax c)
instance GHC.Show.Show c => GHC.Show.Show (Numeric.Opto.Optimizer.AdaMax c)
instance GHC.Classes.Eq c => GHC.Classes.Eq (Numeric.Opto.Optimizer.Adam c)
instance GHC.Show.Show c => GHC.Show.Show (Numeric.Opto.Optimizer.Adam c)
instance GHC.Classes.Eq c => GHC.Classes.Eq (Numeric.Opto.Optimizer.Nesterov c)
instance GHC.Show.Show c => GHC.Show.Show (Numeric.Opto.Optimizer.Nesterov c)
instance GHC.Classes.Eq c => GHC.Classes.Eq (Numeric.Opto.Optimizer.Momentum c)
instance GHC.Show.Show c => GHC.Show.Show (Numeric.Opto.Optimizer.Momentum c)
instance GHC.Real.Fractional c => Data.Default.Class.Default (Numeric.Opto.Optimizer.AdaMax c)
instance GHC.Real.Fractional c => Data.Default.Class.Default (Numeric.Opto.Optimizer.Adam c)
instance GHC.Real.Fractional c => Data.Default.Class.Default (Numeric.Opto.Optimizer.Nesterov c)
instance GHC.Real.Fractional c => Data.Default.Class.Default (Numeric.Opto.Optimizer.Momentum c)


-- | Generate gradients usable with <a>Numeric.Opto</a> using the
--   <i>backprop</i> library.
module Numeric.Opto.Backprop

-- | Turn a simple <tt>a -&gt; b</tt> function into a <tt><a>Grad</a> m
--   a</tt>.
bpGrad :: (Monad m, Backprop a, Backprop b) => (forall s. Reifies s W => BVar s a -> BVar s b) -> Grad m r a

-- | Turn a <tt>a -&gt; b</tt> function parameterized on <tt>r</tt> into a
--   <tt><a>Grad</a> m a</tt>.
bpGradSample :: (Backprop a, Backprop b, Applicative m) => (forall s. Reifies s W => r -> BVar s a -> BVar s b) -> Grad m r a

module Numeric.Opto

-- | Abstraction over types of mutable references for values. A
--   <tt><a>Ref</a> m a v</tt> means that a <tt>v</tt> is a mutable
--   reference to an <tt>a</tt>, and we may update<i>write</i>modify
--   <tt>v</tt> in context <tt>m</tt>.
--   
--   This allows us to reat mutable vectors and in-place mutable numbers or
--   records in the same way.
class Monad m => Ref m a v | v -> a

-- | Initialize a mutable reference with a given value
thawRef :: Ref m a v => a -> m v

-- | Read an immutable value back from a mutable reference
freezeRef :: Ref m a v => v -> m a

-- | Copy an immutable value into a mutable reference
copyRef :: Ref m a v => v -> a -> m ()

-- | Apply a pure function on an immutable value onto a value stored in a
--   mutable reference.
modifyRef :: Ref m a v => v -> (a -> a) -> m ()

-- | <a>modifyRef</a>, but forces the result before storing it back in the
--   reference.
modifyRef' :: Ref m a v => v -> (a -> a) -> m ()

-- | Apply a pure function on an immutable value onto a value stored in a
--   mutable reference, returning a result value from that function.
updateRef :: Ref m a v => v -> (a -> (a, b)) -> m b

-- | <a>updateRef</a>, but forces the updated value before storing it back
--   in the reference.
updateRef' :: Ref m a v => v -> (a -> (a, b)) -> m b
