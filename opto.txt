-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | General-purpose performant numeric optimization library
--   
--   Please see the README on Github at
--   <a>https://github.com/mstksg/opto#readme</a>
@package opto
@version 0.1.0.0

module Data.Type.ZipProd
data ZipProd :: (Type -> Type -> Type) -> [Type] -> [Type] -> Type
[ZPÃ˜] :: ZipProd f '[] '[]
[:<<] :: f a b -> ZipProd f as bs -> ZipProd f (a : as) (b : bs)
onlyZP :: f a b -> ZipProd f '[a] '[b]
headZP :: ZipProd f (a : as) (b : bs) -> f a b
tailZP :: ZipProd f (a : as) (b : bs) -> ZipProd f as bs
traverseZP :: forall h f g as bs. Applicative h => (forall x y. f x y -> h (g x y)) -> ZipProd f as bs -> h (ZipProd g as bs)
mapZP :: (forall x y. f x y -> g x y) -> ZipProd f as bs -> ZipProd g as bs
traverseZP1 :: forall h f g as bs. Applicative h => (forall x y. f x y -> h (g x)) -> ZipProd f as bs -> h (Prod g as)
traverseZP2 :: forall h f g as bs. Applicative h => (forall x y. f x y -> h (g y)) -> ZipProd f as bs -> h (Prod g bs)

module Numeric.Opto.Ref
class Monad m => Ref m a v | v -> a
newRef :: Ref m a v => a -> m v
readRef :: Ref m a v => v -> m a
writeRef :: Ref m a v => v -> a -> m ()
modifyRef :: Ref m a v => v -> (a -> a) -> m ()
modifyRef' :: Ref m a v => v -> (a -> a) -> m ()
updateRef :: Ref m a v => v -> (a -> (a, b)) -> m b
updateRef' :: Ref m a v => v -> (a -> (a, b)) -> m b
data RefInit :: (Type -> Type) -> Type -> Type -> Type
[RI] :: Ref m a v => a -> RefInit m a v
data RefVar :: (Type -> Type) -> Type -> Type -> Type
[RV] :: Ref m a v => v -> RefVar m a v
type RefInits m = ZipProd (RefInit m)
type RefVars m = ZipProd (RefVar m)
initRefs :: Applicative m => ZipProd (RefInit m) as vs -> m (ZipProd (RefVar m) as vs)
readRefs :: Applicative m => ZipProd (RefVar m) as vs -> m (Tuple as)
pullRefs :: Applicative m => ZipProd (RefVar m) as vs -> m (ZipProd (RefInit m) as vs)
instance (Control.Monad.Primitive.PrimMonad m, Control.Monad.Primitive.PrimState m ~ s) => Numeric.Opto.Ref.Ref m a (Data.Primitive.MutVar.MutVar s a)
instance (Control.Monad.Primitive.PrimMonad m, Control.Monad.Primitive.PrimState m ~ s) => Numeric.Opto.Ref.Ref m (Data.Vector.Vector a) (Data.Vector.Mutable.MVector s a)
instance (Control.Monad.Primitive.PrimMonad m, mv ~ Data.Vector.Generic.Base.Mutable v, Control.Monad.Primitive.PrimState m ~ s, Data.Vector.Generic.Base.Vector v a) => Numeric.Opto.Ref.Ref m (Data.Vector.Generic.Sized.Vector v n a) (Data.Vector.Generic.Mutable.Sized.Internal.MVector mv n s a)

module Control.Monad.Sample
class MonadPlus m => MonadSample r m | m -> r
sample :: MonadSample r m => m r
sampleN :: MonadSample r m => Int -> m [r]
data SampleRef v r m a
runSampleRef :: SampleRef v r m a -> v -> m (Maybe a)
foldSampleRef :: (Ref m [r] v, Foldable t) => SampleRef v r m a -> t r -> m (Maybe a, [r])
sampleRef :: (v -> m (Maybe a)) -> SampleRef v r m a
data SampleFoldT r m a
foldSampleFoldT :: Foldable t => SampleFoldT r m a -> t r -> m (Maybe a, [r])
sampleFoldT :: ([r] -> m (Maybe a, [r])) -> SampleFoldT r m a
type SampleFold r = SampleFoldT r Identity
foldSampleFold :: Foldable t => SampleFold r a -> t r -> (Maybe a, [r])
sampleFold :: Monad m => ([r] -> (Maybe a, [r])) -> SampleFoldT r m a
instance GHC.Base.Monad m => GHC.Base.MonadPlus (Control.Monad.Sample.SampleFoldT r m)
instance GHC.Base.Monad m => GHC.Base.Alternative (Control.Monad.Sample.SampleFoldT r m)
instance Control.Monad.Primitive.PrimMonad m => Control.Monad.Primitive.PrimMonad (Control.Monad.Sample.SampleFoldT r m)
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Monad.Sample.SampleFoldT r m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Control.Monad.Sample.SampleFoldT r m)
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Sample.SampleFoldT r m)
instance GHC.Base.Monad m => GHC.Base.MonadPlus (Control.Monad.Sample.SampleRef v r m)
instance GHC.Base.Monad m => GHC.Base.Alternative (Control.Monad.Sample.SampleRef v r m)
instance Control.Monad.Primitive.PrimMonad m => Control.Monad.Primitive.PrimMonad (Control.Monad.Sample.SampleRef v r m)
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Monad.Sample.SampleRef v r m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Control.Monad.Sample.SampleRef v r m)
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Sample.SampleRef v r m)
instance GHC.Base.Monad m => Control.Monad.Sample.MonadSample r (Control.Monad.Sample.SampleFoldT r m)
instance (GHC.Base.Monad m, Numeric.Opto.Ref.Ref m [r] v) => Control.Monad.Sample.MonadSample r (Control.Monad.Sample.SampleRef v r m)

module Numeric.Opto.Update
class Additive a
(.+.) :: Additive a => a -> a -> a
addZero :: Additive a => a
(.+.) :: (Additive a, Num a) => a -> a -> a
addZero :: (Additive a, Num a) => a
sumAdditive :: (Additive a, Foldable t) => t a -> a
class (Num c, Additive a) => Scaling c a | a -> c
(.*) :: Scaling c a => c -> a -> a
scaleOne :: Scaling c a => c
(.*) :: (Scaling c a, Num a, c ~ a) => c -> a -> a
scaleOne :: (Scaling c a, Num c) => c
class Scaling c a => Metric c a
(<.>) :: Metric c a => a -> a -> c
norm_inf :: Metric c a => a -> c
norm_0 :: Metric c a => a -> c
norm_1 :: Metric c a => a -> c
norm_2 :: Metric c a => a -> c
(<.>) :: (Metric c a, Num a, c ~ a) => a -> a -> c
norm_inf :: (Metric c a, Num a, c ~ a) => a -> c
norm_0 :: (Metric c a, Num a, c ~ a) => a -> c
norm_1 :: (Metric c a, Num a, c ~ a) => a -> c
norm_2 :: (Metric c a, Num a, c ~ a) => a -> c
class (Ref m a v, Additive a) => AdditiveInPlace m v a
(.+.=) :: AdditiveInPlace m v a => v -> a -> m ()
sumAdditiveInPlace :: (AdditiveInPlace m v a, Foldable t) => v -> t a -> m ()
class (AdditiveInPlace m v a, Scaling c a) => ScalingInPlace m v c a
(.*=) :: ScalingInPlace m v c a => v -> c -> m ()
(.*+=) :: ScalingInPlace m v c a => v -> (c, a) -> m ()
instance Numeric.Opto.Ref.Ref m GHC.Types.Double v => Numeric.Opto.Update.ScalingInPlace m v GHC.Types.Double GHC.Types.Double
instance (Control.Monad.Primitive.PrimMonad m, Control.Monad.Primitive.PrimState m ~ s, GHC.Num.Num a, mv ~ Data.Vector.Generic.Base.Mutable v, Data.Vector.Generic.Base.Vector v a, GHC.TypeNats.KnownNat n) => Numeric.Opto.Update.ScalingInPlace m (Data.Vector.Generic.Mutable.Sized.Internal.MVector mv n s a) a (Data.Vector.Generic.Sized.Vector v n a)
instance (GHC.TypeNats.KnownNat n, Numeric.Opto.Ref.Ref m (Internal.Static.R n) v) => Numeric.Opto.Update.ScalingInPlace m v GHC.Types.Double (Internal.Static.R n)
instance (GHC.TypeNats.KnownNat n, GHC.TypeNats.KnownNat k, Numeric.Opto.Ref.Ref m (Internal.Static.L n k) v) => Numeric.Opto.Update.ScalingInPlace m v GHC.Types.Double (Internal.Static.L n k)
instance Numeric.Opto.Ref.Ref m GHC.Types.Double v => Numeric.Opto.Update.AdditiveInPlace m v GHC.Types.Double
instance (Control.Monad.Primitive.PrimMonad m, Control.Monad.Primitive.PrimState m ~ s, GHC.Num.Num a, mv ~ Data.Vector.Generic.Base.Mutable v, Data.Vector.Generic.Base.Vector v a, GHC.TypeNats.KnownNat n) => Numeric.Opto.Update.AdditiveInPlace m (Data.Vector.Generic.Mutable.Sized.Internal.MVector mv n s a) (Data.Vector.Generic.Sized.Vector v n a)
instance (GHC.TypeNats.KnownNat n, Numeric.Opto.Ref.Ref m (Internal.Static.R n) v) => Numeric.Opto.Update.AdditiveInPlace m v (Internal.Static.R n)
instance (GHC.TypeNats.KnownNat n, GHC.TypeNats.KnownNat k, Numeric.Opto.Ref.Ref m (Internal.Static.L n k) v) => Numeric.Opto.Update.AdditiveInPlace m v (Internal.Static.L n k)
instance Numeric.Opto.Update.Metric GHC.Types.Double GHC.Types.Double
instance (GHC.Num.Num a, GHC.Classes.Ord a, Data.Vector.Generic.Base.Vector v a, GHC.TypeNats.KnownNat n) => Numeric.Opto.Update.Metric a (Data.Vector.Generic.Sized.Vector v n a)
instance GHC.TypeNats.KnownNat n => Numeric.Opto.Update.Metric GHC.Types.Double (Internal.Static.R n)
instance (GHC.TypeNats.KnownNat n, GHC.TypeNats.KnownNat m) => Numeric.Opto.Update.Metric GHC.Types.Double (Internal.Static.L n m)
instance Numeric.Opto.Update.Scaling GHC.Types.Double GHC.Types.Double
instance (GHC.Num.Num a, Data.Vector.Generic.Base.Vector v a, GHC.TypeNats.KnownNat n) => Numeric.Opto.Update.Scaling a (Data.Vector.Generic.Sized.Vector v n a)
instance GHC.TypeNats.KnownNat n => Numeric.Opto.Update.Scaling GHC.Types.Double (Internal.Static.R n)
instance (GHC.TypeNats.KnownNat n, GHC.TypeNats.KnownNat m) => Numeric.Opto.Update.Scaling GHC.Types.Double (Internal.Static.L n m)
instance Numeric.Opto.Update.Additive GHC.Types.Double
instance (GHC.Num.Num a, Data.Vector.Generic.Base.Vector v a, GHC.TypeNats.KnownNat n) => Numeric.Opto.Update.Additive (Data.Vector.Generic.Sized.Vector v n a)
instance Numeric.Opto.Update.Additive (Internal.Static.R n)
instance (GHC.TypeNats.KnownNat n, GHC.TypeNats.KnownNat m) => Numeric.Opto.Update.Additive (Internal.Static.L n m)

module Numeric.Opto.Core
type Diff a = a
type Grad m a = a -> m (Diff a)
data OptoM :: (Type -> Type) -> Type -> Type -> Type
[MkOptoM] :: ScalingInPlace m v c a => {oInit :: !(RefInits m ss sVars), oUpdate :: !(Grad m a -> RefVars m ss sVars -> a -> m (c, Diff a))} -> OptoM m v a
type Opto s = OptoM (ST s)
fromCopying :: (PrimMonad m, ScalingInPlace m v c a) => s -> (Grad m a -> a -> s -> m (c, Diff a, s)) -> OptoM m v a
fromPure :: (PrimMonad m, ScalingInPlace m v c a) => s -> (Grad m a -> a -> s -> (c, Diff a, s)) -> OptoM m v a
fromStateless :: ScalingInPlace m v c a => (Grad m a -> a -> (c, Diff a)) -> OptoM m v a
fromStatelessM :: ScalingInPlace m v c a => (Grad m a -> a -> m (c, Diff a)) -> OptoM m v a
reGrad :: (Grad m a -> Grad m a) -> OptoM m v a -> OptoM m v a
batching :: forall m v a. AdditiveInPlace m v a => Int -> Grad m a -> Grad m a
batching' :: forall m v a. AdditiveInPlace m v a => Int -> Grad m a -> Grad m a
type GradSample m r a = r -> Grad m a
sampling :: MonadSample r m => GradSample m r a -> Grad m a
batchSampling :: forall r m v a. (MonadSample r m, AdditiveInPlace m v r) => Int -> GradSample m r a -> Grad m a
batchSampling' :: (MonadSample r m, Additive r) => Int -> GradSample m r a -> Grad m a

module Numeric.Opto.Run
iterateOptoM :: forall m v a. Monad m => Grad m a -> (Diff a -> a -> m Bool) -> a -> OptoM m v a -> m (a, OptoM m v a)
iterateOptoM_ :: forall m v a. Monad m => Grad m a -> (Diff a -> a -> m Bool) -> a -> OptoM m v a -> m a
iterateOpto :: (a -> Diff a) -> (Diff a -> a -> Bool) -> a -> (forall s'. Opto s' v a) -> (a, Opto s v a)
iterateOpto_ :: (a -> Diff a) -> (Diff a -> a -> Bool) -> a -> (forall s'. Opto s' v a) -> a
iterateSamplingUntil :: forall m v r a. MonadSample r m => GradSample m r a -> (Diff a -> a -> m Bool) -> a -> OptoM m v a -> m (a, OptoM m v a)
iterateSamplingUntil_ :: forall m v r a. MonadSample r m => GradSample m r a -> (Diff a -> a -> m Bool) -> a -> OptoM m v a -> m a
iterateSampling :: MonadSample r m => GradSample m r a -> a -> OptoM m v a -> m (a, OptoM m v a)
iterateSampling_ :: MonadSample r m => GradSample m r a -> a -> OptoM m v a -> m a

module Numeric.Opto.Algorithms
steepestDescent :: (ScalingInPlace m v c a, Applicative m) => c -> OptoM m v a
data Adam c
Adam :: !c -> !c -> !c -> !c -> Adam c
[adamStep] :: Adam c -> !c
[adamDecay1] :: Adam c -> !c
[adamDecay2] :: Adam c -> !c
[adamEpsilon] :: Adam c -> !c
adam :: forall m v a c. (RealFloat c, Floating a, ScalingInPlace m v c a, PrimMonad m) => Adam c -> OptoM m v a
data AdaMax c
AdaMax :: !c -> !c -> !c -> !c -> AdaMax c
[adaMaxStep] :: AdaMax c -> !c
[adaMaxDecay1] :: AdaMax c -> !c
[adaMaxDecay2] :: AdaMax c -> !c
[adaMaxEpsilon] :: AdaMax c -> !c
adaMax :: forall m v a c. (RealFloat c, Floating a, Metric c a, ScalingInPlace m v c a, PrimMonad m) => AdaMax c -> OptoM m v a
instance GHC.Classes.Eq c => GHC.Classes.Eq (Numeric.Opto.Algorithms.AdaMax c)
instance GHC.Show.Show c => GHC.Show.Show (Numeric.Opto.Algorithms.AdaMax c)
instance GHC.Classes.Eq c => GHC.Classes.Eq (Numeric.Opto.Algorithms.Adam c)
instance GHC.Show.Show c => GHC.Show.Show (Numeric.Opto.Algorithms.Adam c)
instance GHC.Real.Fractional a => Data.Default.Class.Default (Numeric.Opto.Algorithms.AdaMax a)
instance GHC.Real.Fractional a => Data.Default.Class.Default (Numeric.Opto.Algorithms.Adam a)

module Numeric.Opto
