-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | General-purpose performant numeric optimization library
--   
--   Please see the README on Github at
--   <a>https://github.com/mstksg/opto#readme</a>
@package opto
@version 0.1.0.0

module Data.Type.ZipProd
data ZipProd :: (Type -> Type -> Type) -> [Type] -> [Type] -> Type
[ZPÃ˜] :: ZipProd f '[] '[]
[:<<] :: f a b -> ZipProd f as bs -> ZipProd f (a : as) (b : bs)
onlyZP :: f a b -> ZipProd f '[a] '[b]
headZP :: ZipProd f (a : as) (b : bs) -> f a b
tailZP :: ZipProd f (a : as) (b : bs) -> ZipProd f as bs
traverseZP :: forall h f g as bs. Applicative h => (forall x y. f x y -> h (g x y)) -> ZipProd f as bs -> h (ZipProd g as bs)
traverseZP_ :: forall h f as bs. Applicative h => (forall x y. f x y -> h ()) -> ZipProd f as bs -> h ()
mapZP :: (forall x y. f x y -> g x y) -> ZipProd f as bs -> ZipProd g as bs
traverseZP1 :: forall h f g as bs. Applicative h => (forall x y. f x y -> h (g x)) -> ZipProd f as bs -> h (Prod g as)
traverseZP2 :: forall h f g as bs. Applicative h => (forall x y. f x y -> h (g y)) -> ZipProd f as bs -> h (Prod g bs)
zipZipProd :: ZipProd f as bs -> ZipProd g as bs -> ZipProd (Cur (Uncur f :&: Uncur g)) as bs

module Numeric.Opto.Ref
class Monad m => Ref m a v | v -> a
newRef :: Ref m a v => a -> m v
readRef :: Ref m a v => v -> m a
writeRef :: Ref m a v => v -> a -> m ()
modifyRef :: Ref m a v => v -> (a -> a) -> m ()
modifyRef' :: Ref m a v => v -> (a -> a) -> m ()
updateRef :: Ref m a v => v -> (a -> (a, b)) -> m b
updateRef' :: Ref m a v => v -> (a -> (a, b)) -> m b
data RefVal :: (Type -> Type) -> Type -> Type -> Type
[RVl] :: Ref m a v => a -> RefVal m a v
data RefVar :: (Type -> Type) -> Type -> Type -> Type
[RVr] :: Ref m a v => v -> RefVar m a v
type RefVals m = ZipProd (RefVal m)
type RefVars m = ZipProd (RefVar m)
initRefs :: Applicative m => ZipProd (RefVal m) as vs -> m (ZipProd (RefVar m) as vs)
readRefs :: Applicative m => ZipProd (RefVar m) as vs -> m (Tuple as)
pullRefs :: Applicative m => ZipProd (RefVar m) as vs -> m (ZipProd (RefVal m) as vs)
instance GHC.Base.Monad m => Numeric.Opto.Ref.Ref m (Data.Type.ZipProd.ZipProd (Numeric.Opto.Ref.RefVal m) as vs) (Data.Type.ZipProd.ZipProd (Numeric.Opto.Ref.RefVar m) as vs)
instance (Control.Monad.Primitive.PrimMonad m, Control.Monad.Primitive.PrimState m ~ s) => Numeric.Opto.Ref.Ref m a (Data.Primitive.MutVar.MutVar s a)
instance (Control.Monad.Primitive.PrimMonad m, Control.Monad.Primitive.PrimState m ~ s) => Numeric.Opto.Ref.Ref m (Data.Vector.Vector a) (Data.Vector.Mutable.MVector s a)
instance (Control.Monad.Primitive.PrimMonad m, Data.Vector.Generic.Base.Mutable v ~ mv, Control.Monad.Primitive.PrimState m ~ s, Data.Vector.Generic.Base.Vector v a) => Numeric.Opto.Ref.Ref m (Data.Vector.Generic.Sized.Internal.Vector v n a) (Data.Vector.Generic.Mutable.Sized.Internal.MVector mv n s a)

module Control.Monad.Sample

-- | <a>MonadPlus</a> to imply that an empty pool is empty forever unless
--   you re-fill it first.
class MonadPlus m => MonadSample r m | m -> r
sample :: MonadSample r m => m r

-- | Should never fail
sampleN :: (MonadSample r m, Vector v r) => Int -> m (v r)
flushSamples :: MonadSample r m => m [r]

-- | Pulls samples until it cannot pull any more, and returns N shuffled
--   items from the pool. Is O(N) memory.
sampleReservoir :: forall m v r. (PrimMonad m, MonadSample r m, Vector v r) => Int -> Gen (PrimState m) -> m (v r)
data SampleAct m r
SA :: m (Maybe r) -> forall v. Vector v r => Int -> m (Maybe (v r)) -> SampleAct m r
[saSample] :: SampleAct m r -> m (Maybe r)
[saSampleN] :: SampleAct m r -> forall v. Vector v r => Int -> m (Maybe (v r))
newtype SampleT r m a
ST :: MaybeT (ReaderT (SampleAct m r) m) a -> SampleT r m a
[sampleTReader] :: SampleT r m a -> MaybeT (ReaderT (SampleAct m r) m) a
runSampleT :: () => SampleT r m a -> SampleAct m r -> m Maybe a
simpleSA :: forall m r. Monad m => m (Maybe r) -> SampleAct m r
saRef :: Ref m [r] v => v -> SampleAct m r
saState :: MonadState [r] m => SampleAct m r
saConduit :: Monad m => SampleAct (ConduitT r o m) r
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Control.Monad.Sample.SampleT r m)
instance GHC.Base.Monad m => GHC.Base.MonadPlus (Control.Monad.Sample.SampleT r m)
instance GHC.Base.Monad m => GHC.Base.Alternative (Control.Monad.Sample.SampleT r m)
instance Control.Monad.Primitive.PrimMonad m => Control.Monad.Primitive.PrimMonad (Control.Monad.Sample.SampleT r m)
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Monad.Sample.SampleT r m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Control.Monad.Sample.SampleT r m)
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Sample.SampleT r m)
instance Control.Monad.Trans.Class.MonadTrans (Control.Monad.Sample.SampleT r)
instance GHC.Base.Monad m => Control.Monad.Sample.MonadSample r (Control.Monad.Sample.SampleT r m)

module Numeric.Opto.Update
class Additive a
(.+.) :: Additive a => a -> a -> a
addZero :: Additive a => a
(.+.) :: (Additive a, Num a) => a -> a -> a
addZero :: (Additive a, Num a) => a
sumAdditive :: (Additive a, Foldable t) => t a -> a
gAdd :: (ADTRecord a, Constraints a Additive) => a -> a -> a
gAddZero :: (ADTRecord a, Constraints a Additive) => a
class (Num c, Additive a) => Scaling c a | a -> c
(.*) :: Scaling c a => c -> a -> a
scaleOne :: Scaling c a => c
(.*) :: (Scaling c a, ADTRecord a, Constraints a (Scaling c)) => c -> a -> a
scaleOne :: (Scaling c a, Num c) => c
gScale :: forall c a. (ADTRecord a, Constraints a (Scaling c)) => c -> a -> a
class Scaling c a => Metric c a

-- | Sum of component-wise product
(<.>) :: Metric c a => a -> a -> c

-- | Maximum absolute component
norm_inf :: Metric c a => a -> c

-- | Number of non-zero components
norm_0 :: Metric c a => a -> c

-- | Sum of absolute components
norm_1 :: Metric c a => a -> c

-- | Square root of sum of squared components
norm_2 :: Metric c a => a -> c

-- | Sum of squared components
quadrance :: Metric c a => a -> c

-- | Sum of component-wise product
(<.>) :: (Metric c a, ADT a, Constraints a (Metric c)) => a -> a -> c

-- | Maximum absolute component
norm_inf :: (Metric c a, ADT a, Constraints a (Metric c), Ord c) => a -> c

-- | Number of non-zero components
norm_0 :: (Metric c a, ADT a, Constraints a (Metric c)) => a -> c

-- | Sum of absolute components
norm_1 :: (Metric c a, ADT a, Constraints a (Metric c)) => a -> c

-- | Square root of sum of squared components
norm_2 :: (Metric c a, Floating c) => a -> c

-- | Sum of squared components
quadrance :: (Metric c a, ADT a, Constraints a (Metric c)) => a -> c
gNorm_inf :: forall c a. (ADT a, Constraints a (Metric c), Ord c) => a -> c
gNorm_0 :: forall c a. (ADT a, Constraints a (Metric c), Num c) => a -> c
gNorm_1 :: forall c a. (ADT a, Constraints a (Metric c), Num c) => a -> c
gNorm_2 :: forall c a. (ADT a, Constraints a (Metric c), Floating c) => a -> c
gQuadrance :: forall c a. (ADT a, Constraints a (Metric c), Num c) => a -> c
class (Ref m a v, Additive a) => AdditiveInPlace m v a
(.+.=) :: AdditiveInPlace m v a => v -> a -> m ()
sumAdditiveInPlace :: (AdditiveInPlace m v a, Foldable t) => v -> t a -> m ()
class (AdditiveInPlace m v a, Scaling c a) => ScalingInPlace m v c a
(.*=) :: ScalingInPlace m v c a => v -> c -> m ()
(.*+=) :: ScalingInPlace m v c a => v -> (c, a) -> m ()
instance Numeric.Opto.Ref.Ref m GHC.Types.Double v => Numeric.Opto.Update.ScalingInPlace m v GHC.Types.Double GHC.Types.Double
instance (Control.Monad.Primitive.PrimMonad m, Control.Monad.Primitive.PrimState m ~ s, GHC.Num.Num a, mv ~ Data.Vector.Generic.Base.Mutable v, Data.Vector.Generic.Base.Vector v a, GHC.TypeNats.KnownNat n) => Numeric.Opto.Update.ScalingInPlace m (Data.Vector.Generic.Mutable.Sized.Internal.MVector mv n s a) a (Data.Vector.Generic.Sized.Internal.Vector v n a)
instance (GHC.TypeNats.KnownNat n, Numeric.Opto.Ref.Ref m (Internal.Static.R n) v) => Numeric.Opto.Update.ScalingInPlace m v GHC.Types.Double (Internal.Static.R n)
instance (GHC.TypeNats.KnownNat n, GHC.TypeNats.KnownNat k, Numeric.Opto.Ref.Ref m (Internal.Static.L n k) v) => Numeric.Opto.Update.ScalingInPlace m v GHC.Types.Double (Internal.Static.L n k)
instance (Numeric.Opto.Ref.Ref m (a, b) v, Numeric.Opto.Update.Scaling c a, Numeric.Opto.Update.Scaling c b) => Numeric.Opto.Update.ScalingInPlace m v c (a, b)
instance (Numeric.Opto.Ref.Ref m (a, b, d) v, Numeric.Opto.Update.Scaling c a, Numeric.Opto.Update.Scaling c b, Numeric.Opto.Update.Scaling c d) => Numeric.Opto.Update.ScalingInPlace m v c (a, b, d)
instance (Numeric.Opto.Ref.Ref m (a, b, d, e) v, Numeric.Opto.Update.Scaling c a, Numeric.Opto.Update.Scaling c b, Numeric.Opto.Update.Scaling c d, Numeric.Opto.Update.Scaling c e) => Numeric.Opto.Update.ScalingInPlace m v c (a, b, d, e)
instance (Numeric.Opto.Ref.Ref m (a, b, d, e, f) v, Numeric.Opto.Update.Scaling c a, Numeric.Opto.Update.Scaling c b, Numeric.Opto.Update.Scaling c d, Numeric.Opto.Update.Scaling c e, Numeric.Opto.Update.Scaling c f) => Numeric.Opto.Update.ScalingInPlace m v c (a, b, d, e, f)
instance (Numeric.Opto.Ref.Ref m (Numeric.Backprop.Tuple.T2 a b) v, Numeric.Opto.Update.Scaling c a, Numeric.Opto.Update.Scaling c b) => Numeric.Opto.Update.ScalingInPlace m v c (Numeric.Backprop.Tuple.T2 a b)
instance (Numeric.Opto.Ref.Ref m (Numeric.Backprop.Tuple.T3 a b d) v, Numeric.Opto.Update.Scaling c a, Numeric.Opto.Update.Scaling c b, Numeric.Opto.Update.Scaling c d) => Numeric.Opto.Update.ScalingInPlace m v c (Numeric.Backprop.Tuple.T3 a b d)
instance (Numeric.Opto.Ref.Ref m (Numeric.Backprop.Tuple.T as) v, Numeric.Opto.Update.Scaling c (Numeric.Backprop.Tuple.T as)) => Numeric.Opto.Update.ScalingInPlace m v c (Numeric.Backprop.Tuple.T as)
instance Numeric.Opto.Ref.Ref m GHC.Types.Double v => Numeric.Opto.Update.AdditiveInPlace m v GHC.Types.Double
instance (Control.Monad.Primitive.PrimMonad m, Control.Monad.Primitive.PrimState m ~ s, GHC.Num.Num a, mv ~ Data.Vector.Generic.Base.Mutable v, Data.Vector.Generic.Base.Vector v a, GHC.TypeNats.KnownNat n) => Numeric.Opto.Update.AdditiveInPlace m (Data.Vector.Generic.Mutable.Sized.Internal.MVector mv n s a) (Data.Vector.Generic.Sized.Internal.Vector v n a)
instance (GHC.TypeNats.KnownNat n, Numeric.Opto.Ref.Ref m (Internal.Static.R n) v) => Numeric.Opto.Update.AdditiveInPlace m v (Internal.Static.R n)
instance (GHC.TypeNats.KnownNat n, GHC.TypeNats.KnownNat k, Numeric.Opto.Ref.Ref m (Internal.Static.L n k) v) => Numeric.Opto.Update.AdditiveInPlace m v (Internal.Static.L n k)
instance (Numeric.Opto.Ref.Ref m (a, b) v, Numeric.Opto.Update.Additive a, Numeric.Opto.Update.Additive b) => Numeric.Opto.Update.AdditiveInPlace m v (a, b)
instance (Numeric.Opto.Ref.Ref m (a, b, c) v, Numeric.Opto.Update.Additive a, Numeric.Opto.Update.Additive b, Numeric.Opto.Update.Additive c) => Numeric.Opto.Update.AdditiveInPlace m v (a, b, c)
instance (Numeric.Opto.Ref.Ref m (a, b, c, d) v, Numeric.Opto.Update.Additive a, Numeric.Opto.Update.Additive b, Numeric.Opto.Update.Additive c, Numeric.Opto.Update.Additive d) => Numeric.Opto.Update.AdditiveInPlace m v (a, b, c, d)
instance (Numeric.Opto.Ref.Ref m (a, b, c, d, e) v, Numeric.Opto.Update.Additive a, Numeric.Opto.Update.Additive b, Numeric.Opto.Update.Additive c, Numeric.Opto.Update.Additive d, Numeric.Opto.Update.Additive e) => Numeric.Opto.Update.AdditiveInPlace m v (a, b, c, d, e)
instance (Numeric.Opto.Ref.Ref m (Numeric.Backprop.Tuple.T2 a b) v, Numeric.Opto.Update.Additive a, Numeric.Opto.Update.Additive b) => Numeric.Opto.Update.AdditiveInPlace m v (Numeric.Backprop.Tuple.T2 a b)
instance (Numeric.Opto.Ref.Ref m (Numeric.Backprop.Tuple.T3 a b c) v, Numeric.Opto.Update.Additive a, Numeric.Opto.Update.Additive b, Numeric.Opto.Update.Additive c) => Numeric.Opto.Update.AdditiveInPlace m v (Numeric.Backprop.Tuple.T3 a b c)
instance (Numeric.Opto.Ref.Ref m (Numeric.Backprop.Tuple.T as) v, Numeric.Opto.Update.Additive (Numeric.Backprop.Tuple.T as)) => Numeric.Opto.Update.AdditiveInPlace m v (Numeric.Backprop.Tuple.T as)
instance Numeric.Opto.Update.Metric GHC.Types.Double GHC.Types.Double
instance (GHC.Float.Floating a, GHC.Classes.Ord a, Data.Vector.Generic.Base.Vector v a, GHC.TypeNats.KnownNat n) => Numeric.Opto.Update.Metric a (Data.Vector.Generic.Sized.Internal.Vector v n a)
instance GHC.TypeNats.KnownNat n => Numeric.Opto.Update.Metric GHC.Types.Double (Internal.Static.R n)
instance (GHC.TypeNats.KnownNat n, GHC.TypeNats.KnownNat m) => Numeric.Opto.Update.Metric GHC.Types.Double (Internal.Static.L n m)
instance (Numeric.Opto.Update.Metric c a, Numeric.Opto.Update.Metric c b, GHC.Classes.Ord c, GHC.Float.Floating c) => Numeric.Opto.Update.Metric c (a, b)
instance (Numeric.Opto.Update.Metric c a, Numeric.Opto.Update.Metric c b, Numeric.Opto.Update.Metric c d, GHC.Classes.Ord c, GHC.Float.Floating c) => Numeric.Opto.Update.Metric c (a, b, d)
instance (Numeric.Opto.Update.Metric c a, Numeric.Opto.Update.Metric c b, Numeric.Opto.Update.Metric c d, Numeric.Opto.Update.Metric c e, GHC.Classes.Ord c, GHC.Float.Floating c) => Numeric.Opto.Update.Metric c (a, b, d, e)
instance (Numeric.Opto.Update.Metric c a, Numeric.Opto.Update.Metric c b, Numeric.Opto.Update.Metric c d, Numeric.Opto.Update.Metric c e, Numeric.Opto.Update.Metric c f, GHC.Classes.Ord c, GHC.Float.Floating c) => Numeric.Opto.Update.Metric c (a, b, d, e, f)
instance (Numeric.Opto.Update.Metric c a, Numeric.Opto.Update.Metric c b, GHC.Classes.Ord c, GHC.Float.Floating c) => Numeric.Opto.Update.Metric c (Numeric.Backprop.Tuple.T2 a b)
instance (Numeric.Opto.Update.Metric c a, Numeric.Opto.Update.Metric c b, Numeric.Opto.Update.Metric c d, GHC.Classes.Ord c, GHC.Float.Floating c) => Numeric.Opto.Update.Metric c (Numeric.Backprop.Tuple.T3 a b d)
instance Numeric.Opto.Update.Metric c a => Numeric.Opto.Update.Metric c (Numeric.Backprop.Tuple.T '[a])
instance (Numeric.Opto.Update.Metric c b, Numeric.Opto.Update.Metric c (Numeric.Backprop.Tuple.T (a : as)), Numeric.Opto.Update.Scaling c (Numeric.Backprop.Tuple.T (a : as)), Numeric.Opto.Update.Additive a, Type.Family.List.ListC (Numeric.Opto.Update.Additive Type.Family.List.<$> as), Type.Class.Known.Known Data.Type.Length.Length as, GHC.Classes.Ord c, GHC.Float.Floating c) => Numeric.Opto.Update.Metric c (Numeric.Backprop.Tuple.T (b : a : as))
instance Numeric.Opto.Update.Scaling GHC.Types.Double GHC.Types.Double
instance (GHC.Num.Num a, Data.Vector.Generic.Base.Vector v a, GHC.TypeNats.KnownNat n) => Numeric.Opto.Update.Scaling a (Data.Vector.Generic.Sized.Internal.Vector v n a)
instance GHC.TypeNats.KnownNat n => Numeric.Opto.Update.Scaling GHC.Types.Double (Internal.Static.R n)
instance (GHC.TypeNats.KnownNat n, GHC.TypeNats.KnownNat m) => Numeric.Opto.Update.Scaling GHC.Types.Double (Internal.Static.L n m)
instance (Numeric.Opto.Update.Scaling c a, Numeric.Opto.Update.Scaling c b) => Numeric.Opto.Update.Scaling c (a, b)
instance (Numeric.Opto.Update.Scaling c a, Numeric.Opto.Update.Scaling c b, Numeric.Opto.Update.Scaling c d) => Numeric.Opto.Update.Scaling c (a, b, d)
instance (Numeric.Opto.Update.Scaling c a, Numeric.Opto.Update.Scaling c b, Numeric.Opto.Update.Scaling c d, Numeric.Opto.Update.Scaling c e) => Numeric.Opto.Update.Scaling c (a, b, d, e)
instance (Numeric.Opto.Update.Scaling c a, Numeric.Opto.Update.Scaling c b, Numeric.Opto.Update.Scaling c d, Numeric.Opto.Update.Scaling c e, Numeric.Opto.Update.Scaling c f) => Numeric.Opto.Update.Scaling c (a, b, d, e, f)
instance (Numeric.Opto.Update.Scaling c a, Numeric.Opto.Update.Scaling c b) => Numeric.Opto.Update.Scaling c (Numeric.Backprop.Tuple.T2 a b)
instance (Numeric.Opto.Update.Scaling c a, Numeric.Opto.Update.Scaling c b, Numeric.Opto.Update.Scaling c d) => Numeric.Opto.Update.Scaling c (Numeric.Backprop.Tuple.T3 a b d)
instance Numeric.Opto.Update.Scaling c a => Numeric.Opto.Update.Scaling c (Numeric.Backprop.Tuple.T '[a])
instance (Numeric.Opto.Update.Scaling c b, Numeric.Opto.Update.Scaling c (Numeric.Backprop.Tuple.T (a : as)), Numeric.Opto.Update.Additive a, Type.Family.List.ListC (Numeric.Opto.Update.Additive Type.Family.List.<$> as), Type.Class.Known.Known Data.Type.Length.Length as) => Numeric.Opto.Update.Scaling c (Numeric.Backprop.Tuple.T (b : a : as))
instance Numeric.Opto.Update.Additive GHC.Types.Double
instance (GHC.Num.Num a, Data.Vector.Generic.Base.Vector v a, GHC.TypeNats.KnownNat n) => Numeric.Opto.Update.Additive (Data.Vector.Generic.Sized.Internal.Vector v n a)
instance Numeric.Opto.Update.Additive (Internal.Static.R n)
instance (GHC.TypeNats.KnownNat n, GHC.TypeNats.KnownNat m) => Numeric.Opto.Update.Additive (Internal.Static.L n m)
instance (Numeric.Opto.Update.Additive a, Numeric.Opto.Update.Additive b) => Numeric.Opto.Update.Additive (a, b)
instance (Numeric.Opto.Update.Additive a, Numeric.Opto.Update.Additive b, Numeric.Opto.Update.Additive c) => Numeric.Opto.Update.Additive (a, b, c)
instance (Numeric.Opto.Update.Additive a, Numeric.Opto.Update.Additive b, Numeric.Opto.Update.Additive c, Numeric.Opto.Update.Additive d) => Numeric.Opto.Update.Additive (a, b, c, d)
instance (Numeric.Opto.Update.Additive a, Numeric.Opto.Update.Additive b, Numeric.Opto.Update.Additive c, Numeric.Opto.Update.Additive d, Numeric.Opto.Update.Additive e) => Numeric.Opto.Update.Additive (a, b, c, d, e)
instance (Numeric.Opto.Update.Additive a, Numeric.Opto.Update.Additive b) => Numeric.Opto.Update.Additive (Numeric.Backprop.Tuple.T2 a b)
instance (Numeric.Opto.Update.Additive a, Numeric.Opto.Update.Additive b, Numeric.Opto.Update.Additive c) => Numeric.Opto.Update.Additive (Numeric.Backprop.Tuple.T3 a b c)
instance (Type.Family.List.ListC (Numeric.Opto.Update.Additive Type.Family.List.<$> as), Type.Class.Known.Known Data.Type.Length.Length as) => Numeric.Opto.Update.Additive (Numeric.Backprop.Tuple.T as)

module Numeric.Opto.Core
type Diff a = a
type Grad m a = a -> m (Diff a)
data OptoM :: (Type -> Type) -> Type -> Type -> Type
[MkOptoM] :: ScalingInPlace m v c a => {oInit :: !(RefVals m ss sVars), oUpdate :: !(RefVars m ss sVars -> a -> m (c, Diff a))} -> OptoM m v a
type Opto s = OptoM (ST s)
fromCopying :: (PrimMonad m, ScalingInPlace m v c a) => s -> (a -> s -> m (c, Diff a, s)) -> OptoM m v a
fromStateless :: ScalingInPlace m v c a => (a -> m (c, Diff a)) -> OptoM m v a
sampling :: MonadSample r m => (r -> Grad m a) -> Grad m a
pureGrad :: Applicative m => (a -> Diff a) -> Grad m a
pureSampling :: MonadSample r m => (r -> a -> Diff a) -> Grad m a

module Numeric.Opto.Run
data RunOpts m a
RO :: Diff a -> a -> m Bool -> Maybe Int -> Maybe Int -> RunOpts m a
[roStopCond] :: RunOpts m a -> Diff a -> a -> m Bool
[roLimit] :: RunOpts m a -> Maybe Int
[roBatch] :: RunOpts m a -> Maybe Int
runOptoMany :: forall m v a. Alternative m => RunOpts m a -> a -> OptoM m v a -> m (a, OptoM m v a)
evalOptoMany :: forall m v a. Alternative m => RunOpts m a -> a -> OptoM m v a -> m a
runOpto :: forall m v a. Monad m => RunOpts m a -> a -> OptoM m v a -> m (a, OptoM m v a)
evalOpto :: forall m v a. Monad m => RunOpts m a -> a -> OptoM m v a -> m a
data ParallelOpts
PO :: Maybe Int -> Int -> ParallelOpts
[poThreads] :: ParallelOpts -> Maybe Int

-- | how much each thread will process before regrouping
[poSplitRuns] :: ParallelOpts -> Int
runOptoManyParallel :: (MonadUnliftIO m, MonadPlus m, Fractional a) => RunOpts m a -> ParallelOpts -> a -> OptoM m v a -> m (a, [OptoM m v a])
runOptoParallel :: (MonadUnliftIO m, Fractional a) => RunOpts m a -> ParallelOpts -> a -> OptoM m v a -> m (a, [OptoM m v a])

module Numeric.Opto.Run.Conduit
data RunOpts m a
RO :: Diff a -> a -> m Bool -> Maybe Int -> Maybe Int -> RunOpts m a
[roStopCond] :: RunOpts m a -> Diff a -> a -> m Bool
[roLimit] :: RunOpts m a -> Maybe Int
[roBatch] :: RunOpts m a -> Maybe Int

-- | With <a>RunOpts</a>, a chunk size, an initial input, and a
--   <i>sampling</i> optimizer, give a conduit that processes upstream
--   samples and outputs every single one of the updated values as they are
--   generated.
--   
--   Returns the updated optimizer state.
runOptoConduit :: Monad m => RunOpts (SampleT r (ConduitT r a m)) a -> a -> OptoM (SampleT r (ConduitT r a m)) v a -> ConduitT r a m (OptoM (SampleT r (ConduitT r a m)) v a)

-- | <a>runOptoConduit</a>, without returning the updated optimizer state.
runOptoConduit_ :: Monad m => RunOpts (SampleT r (ConduitT r a m)) a -> a -> OptoM (SampleT r (ConduitT r a m)) v a -> ConduitT r a m ()

-- | With <a>RunOpts</a>, a chunk size, an initial input, and a
--   <i>sampling</i> optimizer, give a conduit that processes upstream
--   samples and outputs the updated value only <i>after</i> the optimizer
--   finishes.
--   
--   Returns the updated optimizer state.
runOptoConduitChunk :: Monad m => RunOpts (SampleT r (ConduitT r a m)) a -> a -> OptoM (SampleT r (ConduitT r a m)) v a -> ConduitT r a m (OptoM (SampleT r (ConduitT r a m)) v a)

-- | <a>runOptoConduitChunk</a>, without returning the updated optimizer
--   state.
runOptoConduitChunk_ :: Monad m => RunOpts (SampleT r (ConduitT r a m)) a -> a -> OptoM (SampleT r (ConduitT r a m)) v a -> ConduitT r a m ()
data ParallelOpts
PO :: Maybe Int -> Int -> ParallelOpts
[poThreads] :: ParallelOpts -> Maybe Int

-- | how much each thread will process before regrouping
[poSplitRuns] :: ParallelOpts -> Int

-- | Outputs a shuffled version of the input stream. Keeps entire input
--   stream in memory.
--   
--   NOTE: Pulls the entire input stream into memory first before
--   outputting anything.
shuffling :: PrimMonad m => Gen (PrimState m) -> ConduitT a a m ()

-- | Takes the first N items out of the input stream, shuffles them
--   in-memory, and outputs the shuffled result.
--   
--   Leaves the rest of the items in the stream.
--   
--   Use <a>forever</a> to repeat multiple times until the stream is
--   exhausted.
shufflingN :: PrimMonad m => Int -> Gen (PrimState m) -> ConduitT a a m ()

-- | Process an entire stream, and keep N random and shuffled items from
--   that stream. Is O(N) memory.
sinkSampleReservoir :: forall m v a o. (PrimMonad m, Vector v a) => Int -> Gen (PrimState m) -> ConduitT a o m (v a)

-- | Process an entire stream, and yield N random items from that stream.
--   Is O(N) memory.
--   
--   NOTE: Exhausts the entire input stream first before outputting
--   anything, but never keeps the entire stream in memory.
samplingN :: PrimMonad m => Int -> Gen (PrimState m) -> ConduitT a a m ()

-- | Drops and lets items through randomly with a given probability.
skipSampling :: PrimMonad m => Double -> Gen (PrimState m) -> ConduitT a a m ()

module Numeric.Opto.Optimizer
steepestDescent :: forall m v a c. (ScalingInPlace m v c a, Applicative m) => c -> Grad m a -> OptoM m v a
newtype Momentum c
Momentum :: c -> Momentum c
[momentumDecay] :: Momentum c -> c
momentum :: forall m v a c. (PrimMonad m, ScalingInPlace m v c a) => Momentum c -> c -> Grad m a -> OptoM m v a
newtype Nesterov c
Nesterov :: c -> Nesterov c
[nesterovDecay] :: Nesterov c -> c
nesterov :: forall m v a c. (PrimMonad m, ScalingInPlace m v c a) => Nesterov c -> c -> Grad m a -> OptoM m v a
data Adam c
Adam :: !c -> !c -> !c -> !c -> Adam c
[adamStep] :: Adam c -> !c
[adamDecay1] :: Adam c -> !c
[adamDecay2] :: Adam c -> !c
[adamEpsilon] :: Adam c -> !c
adam :: forall m v a c. (RealFloat c, Floating a, ScalingInPlace m v c a, PrimMonad m) => Adam c -> Grad m a -> OptoM m v a
data AdaMax c
AdaMax :: !c -> !c -> !c -> !c -> AdaMax c
[adaMaxStep] :: AdaMax c -> !c
[adaMaxDecay1] :: AdaMax c -> !c
[adaMaxDecay2] :: AdaMax c -> !c
[adaMaxEpsilon] :: AdaMax c -> !c
adaMax :: forall m v a c. (RealFloat c, Floating a, Metric c a, ScalingInPlace m v c a, PrimMonad m) => AdaMax c -> Grad m a -> OptoM m v a
instance GHC.Classes.Eq c => GHC.Classes.Eq (Numeric.Opto.Optimizer.AdaMax c)
instance GHC.Show.Show c => GHC.Show.Show (Numeric.Opto.Optimizer.AdaMax c)
instance GHC.Classes.Eq c => GHC.Classes.Eq (Numeric.Opto.Optimizer.Adam c)
instance GHC.Show.Show c => GHC.Show.Show (Numeric.Opto.Optimizer.Adam c)
instance GHC.Classes.Eq c => GHC.Classes.Eq (Numeric.Opto.Optimizer.Nesterov c)
instance GHC.Show.Show c => GHC.Show.Show (Numeric.Opto.Optimizer.Nesterov c)
instance GHC.Classes.Eq c => GHC.Classes.Eq (Numeric.Opto.Optimizer.Momentum c)
instance GHC.Show.Show c => GHC.Show.Show (Numeric.Opto.Optimizer.Momentum c)
instance GHC.Real.Fractional c => Data.Default.Class.Default (Numeric.Opto.Optimizer.AdaMax c)
instance GHC.Real.Fractional c => Data.Default.Class.Default (Numeric.Opto.Optimizer.Adam c)
instance GHC.Real.Fractional c => Data.Default.Class.Default (Numeric.Opto.Optimizer.Nesterov c)
instance GHC.Real.Fractional c => Data.Default.Class.Default (Numeric.Opto.Optimizer.Momentum c)

module Numeric.Opto.Backprop
bpGrad :: (Monad m, Num a, Num b) => (forall s. Reifies s W => BVar s a -> BVar s b) -> Grad m a
bpGradSample :: (MonadSample r m, Num a, Num b) => (forall s. Reifies s W => BVar s r -> BVar s a -> BVar s b) -> Grad m a

module Numeric.Opto
