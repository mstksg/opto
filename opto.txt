-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | General-purpose performant numeric optimization library
--   
--   Please see the README on Github at
--   <a>https://github.com/mstksg/opto#readme</a>
@package opto
@version 0.1.0.0

module Data.Type.ZipProd
data ZipProd :: (Type -> Type -> Type) -> [Type] -> [Type] -> Type
[ZPÃ˜] :: ZipProd f '[] '[]
[:<<] :: f a b -> ZipProd f as bs -> ZipProd f (a : as) (b : bs)
onlyZP :: f a b -> ZipProd f '[a] '[b]
headZP :: ZipProd f (a : as) (b : bs) -> f a b
tailZP :: ZipProd f (a : as) (b : bs) -> ZipProd f as bs
traverseZP :: forall h f g as bs. Applicative h => (forall x y. f x y -> h (g x y)) -> ZipProd f as bs -> h (ZipProd g as bs)
mapZP :: (forall x y. f x y -> g x y) -> ZipProd f as bs -> ZipProd g as bs
traverseZP1 :: forall h f g as bs. Applicative h => (forall x y. f x y -> h (g x)) -> ZipProd f as bs -> h (Prod g as)
traverseZP2 :: forall h f g as bs. Applicative h => (forall x y. f x y -> h (g y)) -> ZipProd f as bs -> h (Prod g bs)

module Numeric.Opto.Ref
class Monad m => Ref m a v | v -> a
newRef :: Ref m a v => a -> m v
readRef :: Ref m a v => v -> m a
writeRef :: Ref m a v => v -> a -> m ()
modifyRef :: Ref m a v => v -> (a -> a) -> m ()
modifyRef' :: Ref m a v => v -> (a -> a) -> m ()
updateRef :: Ref m a v => v -> (a -> (a, b)) -> m b
updateRef' :: Ref m a v => v -> (a -> (a, b)) -> m b
data RefInit :: (Type -> Type) -> Type -> Type -> Type
[RI] :: Ref m a v => a -> RefInit m a v
data RefVar :: (Type -> Type) -> Type -> Type -> Type
[RV] :: Ref m a v => v -> RefVar m a v
type RefInits m = ZipProd (RefInit m)
type RefVars m = ZipProd (RefVar m)
initRefs :: Applicative m => ZipProd (RefInit m) as vs -> m (ZipProd (RefVar m) as vs)
readRefs :: Applicative m => ZipProd (RefVar m) as vs -> m (Tuple as)
pullRefs :: Applicative m => ZipProd (RefVar m) as vs -> m (ZipProd (RefInit m) as vs)
instance (Control.Monad.Primitive.PrimMonad m, Control.Monad.Primitive.PrimState m ~ s) => Numeric.Opto.Ref.Ref m a (Data.Primitive.MutVar.MutVar s a)
instance (Control.Monad.Primitive.PrimMonad m, Control.Monad.Primitive.PrimState m ~ s) => Numeric.Opto.Ref.Ref m (Data.Vector.Vector a) (Data.Vector.Mutable.MVector s a)
instance (Control.Monad.Primitive.PrimMonad m, mv ~ Data.Vector.Generic.Base.Mutable v, Control.Monad.Primitive.PrimState m ~ s, Data.Vector.Generic.Base.Vector v a) => Numeric.Opto.Ref.Ref m (Data.Vector.Generic.Sized.Vector v n a) (Data.Vector.Generic.Mutable.Sized.Internal.MVector mv n s a)

module Numeric.Opto.Sample
class MonadPlus m => MonadSample r m | m -> r
sample :: MonadSample r m => m r
data SampleRefT v r m a
runSampleRefT :: SampleRefT v r m a -> v -> m (Maybe a)
foldSampleRefT :: (Ref m [r] v, Foldable t) => SampleRefT v r m a -> t r -> m (Maybe a, [r])
sampleRefT :: (v -> m (Maybe a)) -> SampleRefT v r m a
data SampleFoldT r m a
foldSampleFoldT :: Foldable t => SampleFoldT r m a -> t r -> m (Maybe a, [r])
sampleFoldT :: ([r] -> m (Maybe a, [r])) -> SampleFoldT r m a
instance GHC.Base.Monad m => GHC.Base.MonadPlus (Numeric.Opto.Sample.SampleFoldT r m)
instance GHC.Base.Monad m => GHC.Base.Alternative (Numeric.Opto.Sample.SampleFoldT r m)
instance Control.Monad.Primitive.PrimMonad m => Control.Monad.Primitive.PrimMonad (Numeric.Opto.Sample.SampleFoldT r m)
instance GHC.Base.Monad m => GHC.Base.Monad (Numeric.Opto.Sample.SampleFoldT r m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Numeric.Opto.Sample.SampleFoldT r m)
instance GHC.Base.Functor m => GHC.Base.Functor (Numeric.Opto.Sample.SampleFoldT r m)
instance GHC.Base.Monad m => GHC.Base.MonadPlus (Numeric.Opto.Sample.SampleRefT v r m)
instance GHC.Base.Monad m => GHC.Base.Alternative (Numeric.Opto.Sample.SampleRefT v r m)
instance Control.Monad.Primitive.PrimMonad m => Control.Monad.Primitive.PrimMonad (Numeric.Opto.Sample.SampleRefT v r m)
instance GHC.Base.Monad m => GHC.Base.Monad (Numeric.Opto.Sample.SampleRefT v r m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Numeric.Opto.Sample.SampleRefT v r m)
instance GHC.Base.Functor m => GHC.Base.Functor (Numeric.Opto.Sample.SampleRefT v r m)
instance (GHC.Base.Monad m, Numeric.Opto.Ref.Ref m [r] v) => Numeric.Opto.Sample.MonadSample r (Numeric.Opto.Sample.SampleRefT v r m)

module Numeric.Opto.Update
class Additive a
(.+.) :: Additive a => a -> a -> a
addZero :: Additive a => a
(.+.) :: (Additive a, Num a) => a -> a -> a
addZero :: (Additive a, Num a) => a
class (Num c, Additive a) => Scaling c a | a -> c
(.*) :: Scaling c a => c -> a -> a
scaleOne :: Scaling c a => c
(.*) :: (Scaling c a, Num a, c ~ a) => c -> a -> a
scaleOne :: (Scaling c a, Num c) => c
class Scaling c a => Metric c a
(<.>) :: Metric c a => a -> a -> c
norm_inf :: Metric c a => a -> c
norm_0 :: Metric c a => a -> c
norm_1 :: Metric c a => a -> c
norm_2 :: Metric c a => a -> c
(<.>) :: (Metric c a, Num a, c ~ a) => a -> a -> c
norm_inf :: (Metric c a, Num a, c ~ a) => a -> c
norm_0 :: (Metric c a, Num a, c ~ a) => a -> c
norm_1 :: (Metric c a, Num a, c ~ a) => a -> c
norm_2 :: (Metric c a, Num a, c ~ a) => a -> c
class (Ref m a v, Additive a) => AdditiveInPlace m v a
(.+.=) :: AdditiveInPlace m v a => v -> a -> m ()
class (AdditiveInPlace m v a, Scaling c a) => ScalingInPlace m v c a
(.*=) :: ScalingInPlace m v c a => v -> c -> m ()
(.*+=) :: ScalingInPlace m v c a => v -> (c, a) -> m ()
instance Numeric.Opto.Ref.Ref m GHC.Types.Double v => Numeric.Opto.Update.ScalingInPlace m v GHC.Types.Double GHC.Types.Double
instance (Control.Monad.Primitive.PrimMonad m, Control.Monad.Primitive.PrimState m ~ s, GHC.Num.Num a, mv ~ Data.Vector.Generic.Base.Mutable v, Data.Vector.Generic.Base.Vector v a, GHC.TypeNats.KnownNat n) => Numeric.Opto.Update.ScalingInPlace m (Data.Vector.Generic.Mutable.Sized.Internal.MVector mv n s a) a (Data.Vector.Generic.Sized.Vector v n a)
instance Numeric.Opto.Ref.Ref m GHC.Types.Double v => Numeric.Opto.Update.AdditiveInPlace m v GHC.Types.Double
instance (Control.Monad.Primitive.PrimMonad m, Control.Monad.Primitive.PrimState m ~ s, GHC.Num.Num a, mv ~ Data.Vector.Generic.Base.Mutable v, Data.Vector.Generic.Base.Vector v a, GHC.TypeNats.KnownNat n) => Numeric.Opto.Update.AdditiveInPlace m (Data.Vector.Generic.Mutable.Sized.Internal.MVector mv n s a) (Data.Vector.Generic.Sized.Vector v n a)
instance Numeric.Opto.Update.Metric GHC.Types.Double GHC.Types.Double
instance (GHC.Num.Num a, GHC.Classes.Ord a, Data.Vector.Generic.Base.Vector v a, GHC.TypeNats.KnownNat n) => Numeric.Opto.Update.Metric a (Data.Vector.Generic.Sized.Vector v n a)
instance Numeric.Opto.Update.Scaling GHC.Types.Double GHC.Types.Double
instance (GHC.Num.Num a, Data.Vector.Generic.Base.Vector v a, GHC.TypeNats.KnownNat n) => Numeric.Opto.Update.Scaling a (Data.Vector.Generic.Sized.Vector v n a)
instance Numeric.Opto.Update.Additive GHC.Types.Double
instance (GHC.Num.Num a, Data.Vector.Generic.Base.Vector v a, GHC.TypeNats.KnownNat n) => Numeric.Opto.Update.Additive (Data.Vector.Generic.Sized.Vector v n a)

module Numeric.Opto.Core
type Step a = a
data OptoM :: (Type -> Type) -> Type -> Type -> Type
[MkOptoM] :: ScalingInPlace m v c a => {oInit :: !(RefInits m ss sVars), oUpdate :: !(RefVars m ss sVars -> a -> m (c, Step a))} -> OptoM m v a
type Opto s = OptoM (ST s)
fromCopying :: (PrimMonad m, ScalingInPlace m v c a) => s -> (a -> s -> m (c, Step a, s)) -> OptoM m v a
fromPure :: (PrimMonad m, ScalingInPlace m v c a) => s -> (a -> s -> (c, Step a, s)) -> OptoM m v a
fromStateless :: ScalingInPlace m v c a => (a -> (c, Step a)) -> OptoM m v a
fromStatelessM :: ScalingInPlace m v c a => (a -> m (c, Step a)) -> OptoM m v a
iterateOptoM :: forall m v a. Monad m => (Step a -> a -> m Bool) -> a -> OptoM m v a -> m (a, OptoM m v a)
iterateOpto :: (Step a -> a -> Bool) -> a -> (forall s'. Opto s' v a) -> (a, Opto s v a)

module Numeric.Opto.Stochastic

module Numeric.Opto
steepestDescent :: (ScalingInPlace m v c a, Applicative m) => c -> (a -> a) -> OptoM m v a
steepestDescentM :: (ScalingInPlace m v c a, Applicative m) => c -> (a -> m a) -> OptoM m v a
data Adam c
Adam :: !c -> !c -> !c -> !c -> Adam c
[adamStep] :: Adam c -> !c
[adamDecay1] :: Adam c -> !c
[adamDecay2] :: Adam c -> !c
[adamEpsilon] :: Adam c -> !c
adam :: forall m v a c. (RealFloat c, Floating a, ScalingInPlace m v c a, PrimMonad m) => Adam c -> (a -> m a) -> OptoM m v a
data AdaMax c
AdaMax :: !c -> !c -> !c -> !c -> AdaMax c
[adaMaxStep] :: AdaMax c -> !c
[adaMaxDecay1] :: AdaMax c -> !c
[adaMaxDecay2] :: AdaMax c -> !c
[adaMaxEpsilon] :: AdaMax c -> !c
adaMax :: forall m v a c. (RealFloat c, Floating a, Metric c a, ScalingInPlace m v c a, PrimMonad m) => AdaMax c -> (a -> m a) -> OptoM m v a
instance GHC.Classes.Eq c => GHC.Classes.Eq (Numeric.Opto.AdaMax c)
instance GHC.Show.Show c => GHC.Show.Show (Numeric.Opto.AdaMax c)
instance GHC.Classes.Eq c => GHC.Classes.Eq (Numeric.Opto.Adam c)
instance GHC.Show.Show c => GHC.Show.Show (Numeric.Opto.Adam c)
instance GHC.Real.Fractional a => Data.Default.Class.Default (Numeric.Opto.AdaMax a)
instance GHC.Real.Fractional a => Data.Default.Class.Default (Numeric.Opto.Adam a)
